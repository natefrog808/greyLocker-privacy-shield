/*!
 * Web3.js Minimal Build v1.9.0
 * Simplified version for browser extensions
 * Only includes essential functionality for basic blockchain interactions
 */

(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Web3 = {}));
})(this, (function(exports) {
  'use strict';

  class Web3Provider {
    constructor(provider) {
      this.provider = provider;
      this.connected = false;
      this.chainId = null;
      this.accounts = [];
    }

    async connect() {
      try {
        if (!this.provider) {
          throw new Error('Provider not available');
        }

        const accounts = await this.provider.request({ method: 'eth_requestAccounts' });
        const chainId = await this.provider.request({ method: 'eth_chainId' });
        
        this.accounts = accounts;
        this.chainId = chainId;
        this.connected = true;
        
        return {
          accounts,
          chainId
        };
      } catch (error) {
        console.error('Connection error:', error);
        throw error;
      }
    }

    async disconnect() {
      this.connected = false;
      this.accounts = [];
      this.chainId = null;
      return true;
    }

    async getAccounts() {
      if (!this.connected) {
        throw new Error('Not connected');
      }
      return this.accounts;
    }

    async getChainId() {
      if (!this.connected) {
        throw new Error('Not connected');
      }
      return this.chainId;
    }

    async sendTransaction(transaction) {
      if (!this.connected) {
        throw new Error('Not connected');
      }
      
      try {
        const txHash = await this.provider.request({
          method: 'eth_sendTransaction',
          params: [transaction]
        });
        
        return txHash;
      } catch (error) {
        console.error('Transaction error:', error);
        throw error;
      }
    }

    async signMessage(message, account) {
      if (!this.connected) {
        throw new Error('Not connected');
      }
      
      try {
        const signature = await this.provider.request({
          method: 'personal_sign',
          params: [message, account]
        });
        
        return signature;
      } catch (error) {
        console.error('Signing error:', error);
        throw error;
      }
    }

    onAccountsChanged(callback) {
      if (!this.provider) {
        throw new Error('Provider not available');
      }
      
      this.provider.on('accountsChanged', callback);
    }

    onChainChanged(callback) {
      if (!this.provider) {
        throw new Error('Provider not available');
      }
      
      this.provider.on('chainChanged', callback);
    }

    onDisconnect(callback) {
      if (!this.provider) {
        throw new Error('Provider not available');
      }
      
      this.provider.on('disconnect', callback);
    }
  }

  class Web3Utils {
    static toHex(value) {
      return '0x' + Number(value).toString(16);
    }
    
    static fromHex(hex) {
      return parseInt(hex, 16);
    }
    
    static isAddress(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    }
    
    static toChecksumAddress(address) {
      address = address.toLowerCase().replace('0x', '');
      const hash = this.sha3(address).replace('0x', '');
      let checksumAddress = '0x';
      
      for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
          checksumAddress += address[i];
        }
      }
      
      return checksumAddress;
    }
    
    static sha3(data) {
      // Simple mock of sha3
      return '0x' + Array.from(data).reduce((acc, char) => {
        return acc + char.charCodeAt(0).toString(16);
      }, '');
    }
  }

  // Export main objects
  exports.Web3Provider = Web3Provider;
  exports.utils = Web3Utils;
  exports.version = '1.9.0-minimal';

  // Default export
  Object.defineProperty(exports, '__esModule', { value: true });
}));
